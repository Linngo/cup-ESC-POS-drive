#include <stdio.h>
#include <stdlib.h>
#include <cups/cups.h>
#include <cups/ppd.h>
#include <cups/backend.h>
#include <cups/raster.h>
#include <cups/sidechannel.h>
#include <signal.h>
#include <fcntl.h>

#define DEBUG

#ifdef DEBUG
	#define debug(format, args...) printf(format, ##args)
#else
	#define debug(format, args...)
#endif

#define FILTER_EXIT_SUCCESS 0
#define FILTER_EXIT_ERROR 1

//#define TESTUSB

const char *options[] = {
	"auth-info-required",
	"printer-info",
	"printer-is-accepting-jobs",
	"printer-is-shared",
	"printer-location",
	"printer-make-and-model",
	"printer-state",
	"printer-state-change-time",
	"printer-state-reasons",
	"printer-type",
	NULL
};

void debug_cups_page_header2_t(cups_page_header2_t header);
void debug_cups_page_header2_t(cups_page_header2_t header)
{
#ifdef DEBUG
	debug("cups_page_header2_t: \n");
	debug("unsigned AdvanceDistance: %u\n", header.AdvanceDistance);
	char *cups_adv_t_tostr[] = {
		"CUPS_ADVANCE_FILE", 
		"CUPS_ADVANCE_JOB", 
		"CUPS_ADVANCE_NONE", 
		"CUPS_ADVANCE_PAGE", 
		"CUPS_ADVANCE_SET" };
	debug("cups_adv_t AdvanceMedia: %s\n", 
		cups_adv_t_tostr[header.AdvanceMedia]);
	char *cups_bool_t_tostr[] = { "CUPS_FALSE", "CUPS_TRUE"};
	debug("cups_bool_t Collate: %s\n", cups_bool_t_tostr[header.Collate]);
	char *cups_cut_t_tostr[] = {
		"CUPS_CUT_FILE", 
		"CUPS_CUT_JOB", 
		"CUPS_CUT_NONE", 
		"CUPS_CUT_PAGE", 
		"CUPS_CUT_SET" };
	debug("cups_cut_t CutMedia: %s\n", cups_cut_t_tostr[header.CutMedia]);
	debug("cups_bool_t Duplex: %s\n", cups_bool_t_tostr[header.Duplex]);
	debug("unsigned HWResolution[2]: [0]:%u [1]:%u\n", 
		header.HWResolution[0], header.HWResolution[1]);
	debug("unsigned ImagingBoundingBox[4]: [0]:%u [1]:%u [2]:%u [3]:%u\n", 
		header.ImagingBoundingBox[0], header.ImagingBoundingBox[1], 
		header.ImagingBoundingBox[2], header.ImagingBoundingBox[3]);
	debug("cups_bool_t InsertSheet: %s\n", cups_bool_t_tostr[header.InsertSheet]);
	char *cups_jog_t_tostr[] = {
		"CUPS_JOG_FILE", 
		"CUPS_JOG_JOB", 
		"CUPS_JOG_NONE", 
		"CUPS_JOG_SET" };
	debug("cups_jog_t Jog: %s\n", cups_jog_t_tostr[header.Jog]);
	char *cups_edge_t_tostr[] = {
		"CUPS_EDGE_BOTTON", 
		"CUPS_EDGE_LETF", 
		"CUPS_EDGE_RIGHT", 
		"CUPS_EDGE_TOP" };
	debug("cups_edge_t LeadingEdag: %s\n", cups_edge_t_tostr[header.LeadingEdge]);
	debug("cups_bool_t ManualFeed: %s\n", cups_bool_t_tostr[header.ManualFeed]);
	debug("unsigned Margins[2]: [0]:%d [1]:%d\n", 
		header.Margins[0], header.Margins[1]);
	debug("char MediaClass[64]: %s\n", header.MediaClass);
	debug("char MediaColor[64]: %s\n", header.MediaColor);
	debug("unsigned MediaPosition: %u\n", header.MediaPosition);
	debug("char MediaType[64]: %s\n", header.MediaType);
	debug("unsigned MediaWeight: %u\n", header.MediaWeight);
	debug("cups_bool_t MirrorPrint: %s\n", cups_bool_t_tostr[header.MirrorPrint]);
	debug("cups_bool_t NegativePrint: %s\n", cups_bool_t_tostr[header.NegativePrint]);
	debug("unsigned NumCopies: %u\n", header.NumCopies);
	char *cups_orient_t_tostr[] = {
		"CUPS_ORIENT_0", 
		"CUPS_ORIENT_180", 
		"CUPS_ORIENT_270", 
		"CUPS_ORIENT_90" };
	debug("cups_orient_t Orientation: %s\n", cups_orient_t_tostr[header.Orientation]);
	debug("cups_bool_t OutputFaceUp: %s\n", cups_bool_t_tostr[header.OutputFaceUp]);
	debug("char OutputType[64]: %s\n", header.OutputType);
	debug("unsigned PageSize[2]: [0]:%u [1]:%u\n", 
		header.PageSize[0], header.PageSize[1]);
	debug("cups_bool_t Separations: %s\n", cups_bool_t_tostr[header.Separations]);
	debug("cups_bool_t TraySwitch: %s\n", cups_bool_t_tostr[header.TraySwitch]);
	debug("cups_bool_t Tumble: %s\n", cups_bool_t_tostr[header.Tumble]);
	debug("unsigned cupsBitsPerColor: %u\n", header.cupsBitsPerColor);
	debug("unsigned cupsBitsPerPixel: %u\n", header.cupsBitsPerPixel);
	debug("float cupsBorderlessScalingFactor: %f\n", 
		header.cupsBorderlessScalingFactor);
	debug("unsigned cupsBytesPerLine: %u\n", header.cupsBytesPerLine);
	char *cups_order_t_tostr[] = {
		"CUPS_ORDER_BANDED", 
		"CUPS_ORDER_CHUNKED", 
		"CUPS_ORDER_PLANAR" };
	debug("cups_order_t cupsColorOrder: %s\n", 
		cups_order_t_tostr[header.cupsColorOrder]);
	char *cups_cspace_t_tostr[] = {
		"CUPS_CSPACE_ADOBERGB  CUPS 1.4.5 ", 
		"CUPS_CSPACE_CIELab  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_CIEXYZ  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_CMY ", 
		"CUPS_CSPACE_CMYK ", 
		"CUPS_CSPACE_DEVICE1  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE2  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE3  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE4  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE5  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE6  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE7  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE8  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICE9  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICEA  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICEB  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICEC  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICED  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICEE  CUPS 1.4.5 ", 
		"CUPS_CSPACE_DEVICEF  CUPS 1.4.5 ", 
		"CUPS_CSPACE_GMCK  DEPRECATED ", 
		"CUPS_CSPACE_GMCS  DEPRECATED ", 
		"CUPS_CSPACE_GOLD  DEPRECATED ", 
		"CUPS_CSPACE_ICC1  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC2  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC3  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC4  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC5  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC6  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC7  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC8  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICC9  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCA  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCB  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCC  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCD  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCE  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_ICCF  CUPS 1.1.19/OS X 10.3 ", 
		"CUPS_CSPACE_K ", 
		"CUPS_CSPACE_KCMY  DEPRECATED ", 
		"CUPS_CSPACE_KCMYcm  DEPRECATED ", 
		"CUPS_CSPACE_RGB ", 
		"CUPS_CSPACE_RGBA ", 
		"CUPS_CSPACE_RGBW  CUPS 1.2/OS X 10.5 ", 
		"CUPS_CSPACE_SILVER  DEPRECATED ", 
		"CUPS_CSPACE_SRGB  CUPS 1.4.5 ", 
		"CUPS_CSPACE_SW  CUPS 1.4.5 ", 
		"CUPS_CSPACE_W ", 
		"CUPS_CSPACE_WHITE  DEPRECATED ", 
		"CUPS_CSPACE_YMC  DEPRECATED ", 
		"CUPS_CSPACE_YMCK  DEPRECATED " }; 
			
	debug("cups_cspace_t cupsColorSpace: %d: %s\n", 
		header.cupsColorSpace, cups_cspace_t_tostr[header.cupsColorSpace]);
	debug("unsigned cupsCompression: %u\n", header.cupsCompression);
	debug("unsigned cupsHeight: %u\n", header.cupsHeight);
	debug("float cupsImagingBBox[4]: \n"
		"[0]:%f [1]:%f [2]:%f [3]:%f\n", 
		header.cupsImagingBBox[0], header.cupsImagingBBox[1], 
		header.cupsImagingBBox[2], header.cupsImagingBBox[3]);
	debug("unsigned cupsInteger[16]: \n"
		"[0]:%u [1]:%u [2]:%u [3]:%u \n" 
		"[4]:%u [5]:%u [6]:%u [7]:%u \n"
		"[8]:%u [9]:%u [10]:%u [11]:%u \n" 
		"[12]:%u [13]:%u [14]:%u [15]:%u \n",
		header.cupsInteger[0], header.cupsInteger[1], 
		header.cupsInteger[2], header.cupsInteger[3], 
		header.cupsInteger[4], header.cupsInteger[5], 
		header.cupsInteger[6], header.cupsInteger[7], 
		header.cupsInteger[8], header.cupsInteger[9], 
		header.cupsInteger[10], header.cupsInteger[11], 
		header.cupsInteger[12], header.cupsInteger[13], 
		header.cupsInteger[14], header.cupsInteger[15] );
	debug("char cupsMarkerType[64]: %s\n", header.cupsMarkerType);
	debug("unsigned cupsMediaType: %u\n", header.cupsMediaType);
	debug("unsigned cupsNumColors: %u\n", header.cupsNumColors);
	debug("char cupsPageSizeName[64]: %s\n", header.cupsPageSizeName);
	debug("float cupsPageSize[2]: [0]:%f [1]:%f\n", 
		header.cupsPageSize[0], header.cupsPageSize[1]);
	debug("float cupsReal[16]: \n"
		"[0]:%f [1]:%f [2]:%f [3]:%f \n"
		"[4]:%f [5]:%f [6]:%f [7]:%f \n"
		"[8]:%f [9]:%f [10]:%f [11]:%f \n"
		"[12]:%f [13]:%f [14]:%f [15]:%f \n",
		header.cupsReal[0], header.cupsReal[1], 
		header.cupsReal[2], header.cupsReal[3], 
		header.cupsReal[4], header.cupsReal[5], 
		header.cupsReal[6], header.cupsReal[7], 
		header.cupsReal[8], header.cupsReal[9], 
		header.cupsReal[10], header.cupsReal[11], 
		header.cupsReal[12], header.cupsReal[13], 
		header.cupsReal[14], header.cupsReal[15]);
	debug("char cupsRenderingIntent[64]: %s\n", header.cupsRenderingIntent);
	debug("unsigned cupsRowCount: %u\n", header.cupsRowCount);
	debug("unsigned cupsRowFeed: %u\n", header.cupsRowFeed);
	debug("unsigned cupsRowStep: %u\n", header.cupsRowStep);
	debug("char cupsString[16][64]: \n");
	int i = 0;
	for(i = 0; i<16; i++)
	{
		debug("[%d]: %s\n", i, header.cupsString[i]);
	}
	debug("unsigned cupsWidth: %u\n", header.cupsWidth);
#endif
}

char testCmd[] = { 0x1b, 0x40, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
		0x0a};
void processRaster();
void testusb();

/* first api */
int main(int argc, char *argv[])
{	
#ifdef TESTUSB
	testusb();
	return FILTER_EXIT_ERROR;
#endif
	int i;
	for (i = 0; i<argc; i++)
	{
		debug("argv[%d]: %s\n", i, argv[i]);
	}
	signal(SIGPIPE, SIG_IGN);

	cups_dest_t *dests;
	int num_dests = cupsGetDests(&dests);
	cups_dest_t *dest;

	debug("\n");
	debug("num_dests: %d\n", num_dests);
	debug("\n");
	if (num_dests == 0){
		fputs("ERROR: num_dests == 0 !\n", stderr);
		return FILTER_EXIT_ERROR;
	}
	
	for (i = num_dests, dest = dests; i>0; i--, dest++)
	{
		if (dest == NULL){
			fputs("ERROR: cups_dest_t == NULL !\n", stderr);
			return FILTER_EXIT_ERROR;
		}

		/* do something with dest */
		debug("cups_dest_t struct: \n");
		debug("dest->name: %s\n", dest->name);
		debug("dest->instance: %s\n", dest->instance);
		debug("dest->is_default: %d\n", dest->is_default);
		debug("dest->num_options: %d\n", dest->num_options);
		debug("\n");
	}

	dest = cupsGetDest(NULL, NULL, num_dests, dests);
	debug("default cups_dest selected!\n");

/*
	// debug a list of information
	debug("list of all options: \n");
	for(i = 0; i < dest->num_options; i++){
		debug("%s: %s\n", dest->options[i].name,dest->options[i].value);
	}
*/

/*
	debug("\n");
	debug("get options: \n");
	const char *value;
	for(i = 0;options[i] != NULL; i++){
		value = cupsGetOption(options[i], dest->num_options, dest->options);
		debug("%s: %s\n", options[i],value ? value : "no description");
	}
*/

/*
	int num_options = dest->num_options;
	cups_option_t *options = dest->options;
	int job_id;
*/

/*
	// Print a single file
	job_id = cupsPrintFile(dest->name, "/usr/lib/cups/filter/testpage.bin",
                        "Test Print", num_options, options);
	debug("job_id(Test Print): %d\n", job_id);
*/

/*
	// Print Raw file
	job_id = cupsCreateJob(CUPS_HTTP_DEFAULT, dest->name, "Raw file",
                       num_options, options);
	debug("job_id(Raw file): %d", job_id);
	if (job_id > 0)
	{
		cupsStartDocument(CUPS_HTTP_DEFAULT, dest->name, 
				job_id, "Raw file", CUPS_FORMAT_RAW, 1);
		// can be called as many times as needed
		cupsWriteRequestData(CUPS_HTTP_DEFAULT, 
				testCmd, sizeof(testCmd));
		cupsFinishDocument(CUPS_HTTP_DEFAULT, dest->name);
	}else{
		puts(cupsLastErrorString());
	}
*/

	// Read Raster file and print
	processRaster();

	cupsFreeDests(num_dests, dests);
	return FILTER_EXIT_SUCCESS;
}

void processRaster()
{
	debug("start process raster!\n");

	cups_raster_t *ras = cupsRasterOpen(0, CUPS_RASTER_READ);
	cups_page_header2_t header;
	int rasterpage = 0;
	int y;
	int i;
	unsigned char *rasbuf;

	while(cupsRasterReadHeader2(ras, &header))
	{
		// setup this page 
	        rasterpage++;
        	fprintf(stderr, "PAGE: %d %d\n", rasterpage, header.NumCopies);
		debug("rasterpage %d, cupsRasterReadHeader2 success!\n", rasterpage);
		//debug_cups_page_header2_t(header);
		
		// process the data then put it into standard output
		rasbuf = malloc(8 + header.cupsBytesPerLine);
		for (y = 0; y < header.cupsHeight; y ++)
		{
			if (cupsRasterReadPixels(ras, 
				rasbuf + 8, header.cupsBytesPerLine) == 0)
				break;
			rasbuf[0] = 0x1D;
			rasbuf[1] = 0x76;
			rasbuf[2] = 0x30;
			rasbuf[3] = 0x00;
			rasbuf[4] = (unsigned char)(header.cupsBytesPerLine & 0xff);
			rasbuf[5] = (unsigned char)((header.cupsBytesPerLine & 0xff00) >> 8);
			rasbuf[6] = 0x01;
			rasbuf[7] = 0x00;
			
			// for usb we should have different founction
			// if the device is connect from usb port, we check the vid and pid
			for(i = 0; i < 8 + header.cupsBytesPerLine; i++)
				putchar(rasbuf[i]);
		}
		// page finished
		free(rasbuf);
	} 
	cupsRasterClose(ras);
}

void testusb()
{
	int deviceport = 0; 
	FILE *fp;
	const char * devicefilepath = "/dev/usb/lp0";
	if ((fp = fopen(devicefilepath, "a")) != NULL)
		deviceport = 1;
	debug("deviceprot: %d\n", deviceport);
	if(deviceport == 1)
	{
		fputc(0x0a, fp);
		fputc(0x0a, fp);
		fputc(0x0a, fp);
		fputc(0x0a, fp);
		fclose(fp);
	}
}
